//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
fx quad.vs fx.fs
multi basic.vs multi.fs
basiclight basic.vs basiclight.fs
normal basic.vs normal.fs
uvs basic.vs uvs.fs
occlusion basic.vs occlusion.fs
multipasslight basic.vs multipasslight.fs
gbuffers basic.vs gbuffers.fs
deferred quad.vs deferred.fs
finalShader quad.vs finalShader.fs
tonemapper quad.vs tonemapper.fs
deferred_sphere basic.vs deferred.fs
ssao quad.vs ssao.fs
blur quad.vs blur.fs
probe basic.vs probe.fs

\irrProbes
const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; }; //to store colors

void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
    // Band 0
    sh.c[0] = 0.282095 * CosineA0;
    // Band 1
    sh.c[1] = 0.488603 * dir.y * CosineA1; 
    sh.c[2] = 0.488603 * dir.z * CosineA1;
    sh.c[3] = 0.488603 * dir.x * CosineA1;
    // Band 2
    sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
    sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
    sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
    sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
    sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
    // Compute the cosine lobe in SH, oriented about the normal direction
    SH9 shCosine;
    SHCosineLobe(normal, shCosine);
    // Compute the SH dot product to get irradiance
    vec3 irradiance = vec3(0.0);
    for(int i = 0; i < 9; ++i)
        irradiance += sh.c[i] * shCosine.c[i];

    return irradiance;
}


vec3 computeIndexIrr(vec3 indices, vec3 dim, float num_probes, sampler2D probes_texture, vec3 N){
	//compute in which row is the probe stored
	float row = indices.x + indices.y * dim.x + indices.z * dim.x * dim.y;

	//find the UV.y coord of that row in the probes texture
	float row_uv = (row + 1.0) / (num_probes + 1.0);

	SH9Color sh;
	//fill the coefficients
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; ++i)
	{
		vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
		sh.c[i] = texture( probes_texture, coeffs_uv).xyz;
	}

	//now we can use the coefficients to compute the irradiance
	vec3 irradiance = ComputeSHIrradiance( N, sh );

	return irradiance;
}

vec3 computeIrradiance(vec3 irr_start, vec3 irr_end, vec3 worldpos, float irr_normal_distance, vec3 irr_delta, vec3 irr_dims, float num_probes, sampler2D probes_texture, vec3 N){

	//computing nearest probe index based on world position
	vec3 irr_range = irr_end - irr_start;
	vec3 irr_local_pos = clamp( worldpos - irr_start + N * irr_normal_distance, /*offset a little*/	vec3(0.0), irr_range );

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = round( irr_norm_pos );

	//now we can use the coefficients to compute the irradiance
	vec3 irradiance = computeIndexIrr(local_indices, irr_dims, num_probes, probes_texture, N);

	return irradiance;
	
} 

vec3 computeTriIrradiance(vec3 irr_start, vec3 irr_end, vec3 worldpos, float irr_normal_distance, vec3 irr_delta, vec3 irr_dims, float num_probes, sampler2D probes_texture, vec3 N){

	//computing nearest probe index based on world position
	vec3 irr_range = irr_end - irr_start;
	vec3 irr_local_pos = clamp( worldpos - irr_start + N * irr_normal_distance, /*offset a little*/	vec3(0.0), irr_range );

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = floor(irr_norm_pos);

	//now we have the interpolation factors
	vec3 factors = irr_norm_pos - local_indices; 

	//local_indices points to Left,Bottom,Far
	vec3 indicesLBF = local_indices;
	vec3 indicesRBF = local_indices;
	indicesRBF.x += 1;
	
	vec3 indicesLTF = local_indices;
	indicesLTF.y += 1; 

	vec3 indicesRTF = local_indices;
	indicesRTF.x += 1; 
	indicesRTF.y += 1; 

	vec3 indicesLBN = local_indices;
	indicesLBN.z += 1;

	vec3 indicesRBN = local_indices;
	indicesRBN.x += 1; 
	indicesRBN.z += 1; 

	vec3 indicesLTN = local_indices;
	indicesLTN.y += 1; 
	indicesLTN.z += 1; 


	vec3 indicesRTN = local_indices;
	indicesRTN.x += 1; 
	indicesRTN.y += 1; 
	indicesRTN.z += 1; 



	//compute irradiance for every corner
	vec3 irrLBF = computeIndexIrr( indicesLBF, irr_dims, num_probes, probes_texture, N );
	vec3 irrRBF = computeIndexIrr( indicesRBF, irr_dims, num_probes, probes_texture, N );
	vec3 irrLTF = computeIndexIrr( indicesLTF, irr_dims, num_probes, probes_texture, N );
	vec3 irrRTF = computeIndexIrr( indicesRTF, irr_dims, num_probes, probes_texture, N );
	vec3 irrLBN = computeIndexIrr( indicesLBN, irr_dims, num_probes, probes_texture, N );
	vec3 irrRBN = computeIndexIrr( indicesRBN, irr_dims, num_probes, probes_texture, N );
	vec3 irrLTN = computeIndexIrr( indicesLTN, irr_dims, num_probes, probes_texture, N );
	vec3 irrRTN = computeIndexIrr( indicesRTN, irr_dims, num_probes, probes_texture, N );

	vec3 irrTF = mix( irrLTF, irrRTF, factors.x );
	vec3 irrBF = mix( irrLBF, irrRBF, factors.x );
	vec3 irrTN = mix( irrLTN, irrRTN, factors.x );
	vec3 irrBN = mix( irrLBN, irrRBN, factors.x );

	vec3 irrT = mix( irrTF, irrTN, factors.z );
	vec3 irrB = mix( irrBF, irrBN, factors.z );

	vec3 irr = mix( irrB, irrT, factors.y );

	return irr;
	
} 


\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}


\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}



\computeNormal

mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}

// assume N, the interpolated vertex normal and 
// WP the world position
//vec3 normal_pixel = texture2D( normalmap, uv ).xyz; 
vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
    normal_pixel = normal_pixel * 255./127. - 128./127.;
    mat3 TBN = cotangent_frame(N, WP, uv);
    return normalize(TBN * normal_pixel);
}


\computeShadowFactor
float getShadowFactor(bool directional, vec3 world_position, mat4 shadow_viewproj, float shadow_bias, sampler2D shadowmap)
{
//project our 3D position to the shadowmap
	vec4 proj_pos = shadow_viewproj * vec4(world_position,1.0);

	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;

	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);

	//get point depth [-1 .. +1] in non-linear space
	float real_depth = (proj_pos.z - shadow_bias) / proj_pos.w;

	//normalize from [-1..+1] to [0..+1] still non-linear
	real_depth = real_depth * 0.5 + 0.5;

	//read depth from depth buffer in [0..+1] non-linear
	float shadow_depth = texture( shadowmap, shadow_uv).x;

	//compute final shadow factor by comparing
	float shadow_factor = 1.0;

	//we can compare them, even if they are not linear
	if( shadow_depth < real_depth )
		shadow_factor = 0.0;

	if (directional){

		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 ||
		shadow_uv.y < 0.0 || shadow_uv.y > 1.0 )
			shadow_factor = 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			shadow_factor = 1.0;

	}
		
	
	return shadow_factor;
}


\basiclight.fs

#version 330 core

const int MAX_LIGHTS = 5;
in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform vec3 u_emissive_factor;

uniform sampler2D u_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_emmisive_texture;
uniform sampler2D u_normalmap;


uniform int u_light_type[MAX_LIGHTS];
uniform vec3 u_light_pos[MAX_LIGHTS];
uniform vec3 u_light_color[MAX_LIGHTS];
uniform vec3 u_light_intensity[MAX_LIGHTS];
uniform vec3 u_light_target[MAX_LIGHTS];
uniform float u_light_max_dists[MAX_LIGHTS];
uniform float u_light_coscutoff[MAX_LIGHTS];
uniform float u_light_spotexp[MAX_LIGHTS];
uniform int u_num_lights;


uniform float u_time;
uniform float u_alpha_cutoff;

uniform vec3 u_ambient_light;

out vec4 FragColor;

#include "computeNormal"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	float occlusion = texture( u_metallic_roughness_texture, v_uv ).x;

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light = u_ambient_light * occlusion;

	vec3 N = normalize(v_normal);

	vec3 normal_uv = texture2D(u_normalmap,v_uv).xyz;
	N = perturbNormal(N, v_world_position, v_uv, normal_uv);

	
	for( int i = 0; i < MAX_LIGHTS; ++i ){
		if(i < u_num_lights){
			vec3 L;

			float att_factor = 1;
			float spotFactor = 1;

			vec3 D = normalize(u_light_target[i]);

			if (u_light_type[i] == 2){
				L = -D;
			}
			else{
				L = u_light_pos[i] - v_world_position;
				att_factor = u_light_max_dists[i] - length(L);
				att_factor /= u_light_max_dists[i];
				att_factor = max( att_factor, 0.0 );
				L = normalize(L);
				if (u_light_type[i] == 1){
					if (u_light_coscutoff[i] > 0.0) { 
						float spotCosine = dot(D,-L);
						if (spotCosine >= u_light_coscutoff[i]) { 
							spotFactor = pow(spotCosine, u_light_spotexp[i]);
						}
						else{
							spotFactor = 0;
						}
					}
				}
			}
			float NdotL = clamp( dot(L,N), 0.0, 1.0);
			light += NdotL * u_light_color[i] * u_light_intensity[i] * att_factor * spotFactor;
		}
	}


	color.xyz *= light;

	color.xyz += u_emissive_factor * texture(u_emmisive_texture, v_uv).xyz;

	FragColor = color;
}


\includeLights

uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform vec3 u_light_target;
uniform float u_light_intensity;
uniform float u_light_max_dists;
uniform float u_light_coscutoff;
uniform float u_light_spotexp;
uniform int u_num_lights;
uniform int u_light_type;

uniform vec3 u_ambient_light;


\multipasslight.fs

#version 330 core

#include "includeLights"

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform vec3 u_emissive_factor;

uniform sampler2D u_texture;
uniform sampler2D u_emmisive_texture;
uniform sampler2D u_normalmap;

uniform sampler2D u_metallic_roughness_texture;


uniform sampler2D u_shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;
uniform bool u_cast_shadows;


uniform float u_time;
uniform float u_alpha_cutoff;


out vec4 FragColor;

#include "computeShadowFactor"
#include "computeNormal"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	
	float occlusion = texture2D(u_metallic_roughness_texture, v_uv ).x;

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light = u_ambient_light * occlusion;
	vec3 N = normalize(v_normal);

	vec3 normal_uv = texture2D(u_normalmap,v_uv).xyz;
	N = perturbNormal(N, v_world_position, v_uv, normal_uv);



	vec3 L;

	float att_factor = 1.0;
	float spotFactor = 1.0;
	float shadow_factor = 1.0;

	vec3 D = normalize(u_light_target);

	if (u_light_type == 2){
		L = -D;
		if (u_cast_shadows) shadow_factor = getShadowFactor(true, v_world_position, u_shadow_viewproj, u_shadow_bias, u_shadowmap);
	}
	else{
		L = u_light_pos - v_world_position;
		att_factor = u_light_max_dists - length(L);
		att_factor /= u_light_max_dists;
		att_factor = max( att_factor, 0.0 );
		L = normalize(L);
		if (u_light_type == 1){
			if (u_cast_shadows) shadow_factor = getShadowFactor(false, v_world_position, u_shadow_viewproj, u_shadow_bias, u_shadowmap);
			if (u_light_coscutoff > 0.0) { 
				float spotCosine = dot(D,-L);
				if (spotCosine >= u_light_coscutoff) { 
					spotFactor = pow(spotCosine, u_light_spotexp);
				}
				else{
					spotFactor = 0;
				}
			}
		}
	}



	float NdotL = clamp( dot(L,N), 0.0, 1.0);
	
	light += NdotL * u_light_color * u_light_intensity * att_factor * spotFactor * shadow_factor;

	color.xyz *= light;

	color.xyz += u_emissive_factor * texture(u_emmisive_texture, v_uv).xyz;

	FragColor = color;
}

\dithering
float dither4x4(vec2 position, float brightness)
{
  int x = int(mod(position.x, 4.0));
  int y = int(mod(position.y, 4.0));
  int index = x + y * 4;
  float limit = 0.0;

  if (x < 8) {
    if (index == 0) limit = 0.0625;
    if (index == 1) limit = 0.5625;
    if (index == 2) limit = 0.1875;
    if (index == 3) limit = 0.6875;
    if (index == 4) limit = 0.8125;
    if (index == 5) limit = 0.3125;
    if (index == 6) limit = 0.9375;
    if (index == 7) limit = 0.4375;
    if (index == 8) limit = 0.25;
    if (index == 9) limit = 0.75;
    if (index == 10) limit = 0.125;
    if (index == 11) limit = 0.625;
    if (index == 12) limit = 1.0;
    if (index == 13) limit = 0.5;
    if (index == 14) limit = 0.875;
    if (index == 15) limit = 0.375;
  }

  return brightness < limit ? 0.0 : 1.0;
}

\gbuffers.fs

#version 330 core
#include "dithering"

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform vec3 u_emissive_factor;

uniform sampler2D u_texture;
uniform sampler2D u_emmisive_texture;
uniform sampler2D u_normalmap;

uniform sampler2D u_metallic_roughness_texture;
uniform float u_metallic_factor;
uniform float u_roughness_factor;


uniform float u_time;
uniform float u_alpha_cutoff;

uniform bool u_dithering;

uniform vec3 u_ambient_light;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;
layout(location = 2) out vec4 ExtraColor;
layout(location = 3) out vec4 occlusion;



void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if (u_dithering){
		if(color.a < 0.9 && dither4x4( gl_FragCoord.xy, color.a) == 0.0)
			discard;
	}
	else{
		if(color.a < u_alpha_cutoff)
			discard;
	}

	
	vec3 metallic_roughness = texture2D(u_metallic_roughness_texture, v_uv ).xyz;

	float occlusion = metallic_roughness.x;
	float roughness = metallic_roughness.y * u_roughness_factor;
	float metalness = metallic_roughness.z * u_metallic_factor;

	vec3 emmisive = u_emissive_factor * texture(u_emmisive_texture, v_uv).xyz;

	vec3 N = normalize( v_normal );
	FragColor = vec4(color.xyz, roughness);
	NormalColor = vec4(N * 0.5 + vec3(0.5), metalness);
	ExtraColor = vec4(emmisive, occlusion);//vec4(v_world_position, 1.0);
}


\computePBR

#define RECIPROCAL_PI 0.3183098861837697
#define PI 3.14159265359

// Geometry Term: Geometry masking/shadowing due to microfacets
float GGX(float NdotV, float k)
{
    return NdotV / (NdotV * (1.0 - k) + k);
}

float D_GGX ( const in float NoH, const in float linearRoughness )
{
    float a2 = linearRoughness * linearRoughness;
    float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (PI * f * f);
}

// Fresnel term with colorized fresnel
vec3 F_Schlick( const in float VoH, const in vec3 f0)
{
    float f = pow(1.0 - VoH, 5.0);
    return f0 + (vec3(1.0) - f0) * f;
}

//From filament: https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf
float F_Schlick(float u, float f0, float f90) {
    return f0 + (f90 - f0) * pow(1.0 - u, 5.0);
}


float G_Smith( float NdotV, float NdotL, float roughness)
{
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return GGX(NdotL, k) * GGX(NdotV, k);
}

vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

    // Fresnel Function
    vec3 F = F_Schlick( LoH, f0 );

    // Visibility Function (shadowing/masking)
    float G = G_Smith( NoV, NoL, roughness );
        
    // Norm factor
    vec3 spec = D * G * F;
    spec /= (4.0 * NoL * NoV + 1e-6);

    return spec;
}

// Diffuse Reflections: Disney BRDF using retro-reflections using F term, this is much more complex!!
float Fd_Burley ( const in float NoV, const in float NoL, const in float LoH, const in float linearRoughness)
{
        float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;
        float lightScatter = F_Schlick(NoL, 1.0, f90);
        float viewScatter  = F_Schlick(NoV, 1.0, f90);
        return lightScatter * viewScatter * RECIPROCAL_PI;
}


\hdr
vec3 degamma(vec3 c)
{
	return pow(c,vec3(2.2));
}

vec3 gamma(vec3 c)
{
	return pow(c,vec3(1.0/2.2));;
}





\deferred.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_ao_texture;

uniform vec3 u_camera_position;
uniform mat4 u_inverse_viewprojection;

uniform sampler2D u_shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;
uniform bool u_cast_shadows;
uniform bool u_first_iter;
uniform bool hdr;

uniform bool u_apply_ssao;

uniform sampler2D u_probes_texture;
uniform float u_num_probes;
uniform float u_irr_normal_dist;
uniform bool u_apply_irr;
uniform bool u_tri_irr;
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dim;
uniform vec3 u_irr_delta;


uniform float u_time;
out vec4 FragColor;

#include "includeLights"
#include "irrProbes"
#include "computeShadowFactor"
#include "computePBR"
#include "hdr"

// #include "computeNormal"
// vec3 normal_uv = texture2D(u_normalmap,v_uv).xyz;
// N = perturbNormal(N, v_world_position, v_uv, normal_uv);


void main()
{
	vec2 uv = v_uv; //slides frag cord posible
	vec4 albedo = texture( u_color_texture, uv );

	vec4 normal = texture( u_normal_texture, uv );
	vec4 extra = texture( u_extra_texture, uv );


	vec3 linearAlbedo;
	vec3 linearEmmisive;
	if(hdr){
		linearAlbedo = degamma(albedo.xyz);
		linearEmmisive = degamma(extra.xyz);
	}
	else{
		linearAlbedo = albedo.xyz;
		linearEmmisive = extra.xyz;
	};


	//vec4 depth = texture( u_depth_texture, uv );
	float metalness = normal.a;
	float roughness = albedo.a;
	float occlusion = extra.x;
	vec3 irradiance = vec3(1.0);

	float depth = texture( u_depth_texture, uv ).x;

    vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
    vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
    vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;

	vec3 N = normalize(normal.xyz * 2.0 - vec3(1.0));
	float NdotL = 0.0;

	if(u_apply_ssao){
		vec4 ao = texture( u_ao_texture, uv );
		occlusion = ao.x;
	}

	// if(u_first_iter)
	if(u_apply_irr){
		if(u_tri_irr) irradiance = computeTriIrradiance(u_irr_start, u_irr_end, worldpos, u_irr_normal_dist, u_irr_delta, u_irr_dim, u_num_probes, u_probes_texture, N);
		else irradiance = computeIrradiance(u_irr_start, u_irr_end, worldpos, u_irr_normal_dist, u_irr_delta, u_irr_dim, u_num_probes, u_probes_texture, N);
	}

	// vec3 finalIrrWOcc = irradiance * occlusion;

	vec3 L;

	float att_factor = 1.0;
	float spotFactor = 1.0;
	float shadow_factor = 1.0;

	vec3 light = vec3(0.0);
	if(u_first_iter){
		if (u_apply_irr){
			light+= irradiance;
		}
		else{
			if(hdr){
				light += degamma(u_ambient_light);
			}
			else{
				light += u_ambient_light;
			};
		}
	}
	light *= occlusion;

			//light += u_ambient_light;


	//light *= finalIrrWOcc;
	vec3 D = normalize(u_light_target);

	if (u_light_type == 2){
		L = -D;
		if (u_cast_shadows) shadow_factor = getShadowFactor(true, worldpos, u_shadow_viewproj, u_shadow_bias, u_shadowmap);
	}
	else{
		L = u_light_pos - worldpos;
		float sizeL = length(L);
		att_factor = u_light_max_dists - sizeL;
		att_factor /= u_light_max_dists;
		att_factor = max( att_factor, 0.0 );
		L /= sizeL;
		if (u_light_type == 1){
			if (u_cast_shadows) shadow_factor = getShadowFactor(false, worldpos, u_shadow_viewproj, u_shadow_bias, u_shadowmap);
			if (u_light_coscutoff > 0.0) { 
				float spotCosine = dot(D,-L);
				if (spotCosine >= u_light_coscutoff) { 
					spotFactor = pow(spotCosine, u_light_spotexp);
				}
				else{
					spotFactor = 0.0;
				}
			}
		}
	}

	NdotL = clamp( dot(L,N), 0.0, 1.0);
	vec3 V = normalize(u_camera_position - worldpos);
	vec3 H = normalize(V+L);

	float NdotH = clamp( dot(H,N), 0.0, 1.0);
	float NdotV = clamp( dot(V,N), 0.0, 1.0);
	float LdotH = clamp( dot(H,L), 0.0, 1.0);

	//we compute the reflection in base to the color and the metalness
	vec3 f0 = mix( vec3(0.5), linearAlbedo, metalness);

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * linearAlbedo;

	//compute the specular
	vec3 Fr_d = NdotL * specularBRDF(  roughness, f0, NdotH, NdotV, NdotL, LdotH);

	// Here we use the Burley, but you can replace it by the Lambert.
	// linearRoughness = squared roughness
	//vec3 Fd_d = diffuseColor * Fd_Burley(NdotV,NdotL,LdotH,(roughness*roughness)); 
	vec3 Fd_d = diffuseColor * NdotL;
	vec3 direct = Fr_d + Fd_d;

	//compute how much light received the pixel

	vec3 lightParams;

	if(hdr){
		lightParams = degamma(u_light_color) * u_light_intensity * att_factor * shadow_factor * spotFactor;
	}
	else{
		lightParams = u_light_color * u_light_intensity * att_factor * shadow_factor * spotFactor;
	};
	light += direct * lightParams;

	//modulate direct light by light received

	vec3 color = linearAlbedo * light;
	
	if(u_first_iter){
		color += linearEmmisive;
	}

	FragColor = vec4(color, 1.0);

}


\normal.fs

#version 330 core

in vec3 v_normal;
out vec4 FragColor;

void main()
{
	FragColor = vec4( abs(normalize(v_normal)), 1.0);
}

\uvs.fs

#version 330 core

in vec2 v_uv;

out vec4 FragColor;

void main()
{

	FragColor = vec4(v_uv, 1.0, 1.0);
}

\occlusion.fs

#version 330 core

in vec2 v_uv;
uniform sampler2D u_metallic_roughness_texture;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	float occ = texture( u_metallic_roughness_texture, v_uv ).x;
	FragColor = vec4(occ, occ, occ, 1.0);
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}

\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	FragColor = vec4(color);
}


\fx.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture; //depth map
uniform float u_time;
out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = texture( u_texture, uv );
	color = vec4(1.0) - color;
	FragColor = color;
}


\finalShader.fs

#version 330 core

#include "hdr"

in vec2 v_uv;

uniform sampler2D u_texture;
out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = texture(u_texture,uv);
	color.xyz = gamma(color.xyz);
	FragColor = color;
}


\tonemapper.fs

#version 330 core
#include "hdr"

in vec2 v_uv;

uniform sampler2D u_texture; //depth map

uniform float u_average_lum; //	average_lum = 1.0;
uniform float u_lumwhite2; //	lum_white = 1.0;
uniform float u_scale; //	scale_tm = 1.0;

out vec4 FragColor;

void main() {
	vec2 uv = v_uv;
	vec4 color = texture2D( u_texture, uv );
	vec3 rgb = color.xyz;

	float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
	float L = (u_scale / u_average_lum) * lum;
	float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);

	rgb = (rgb / lum) * Ld;
	rgb = max(rgb,vec3(0.001));
	rgb = gamma(rgb);
	
	FragColor = vec4( rgb, 1.0);
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\ssao.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_normal_texture;
uniform sampler2D u_depth_texture;
uniform mat4 u_viewprojection;

uniform vec2 u_iRes;
uniform mat4 u_inverse_viewprojection;

#define SAMPLES 64

uniform vec3 u_points[SAMPLES];

out vec4 FragColor;

mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}


void main(){

	float intensity = 1.0;

	vec2 uv = v_uv + u_iRes * 0.5;

	//read depth from depth buffer
	float depth = texture( u_depth_texture, uv ).x;
	vec3 normal = texture( u_normal_texture, uv ).xyz * 2.0 - vec3(1.0);

	//ignore pixels in the background
	if(depth >= 1.0)
	{
		FragColor = vec4(1.0);
		return;
	}

	//create screenpos with the right depth
	vec4 screen_position = vec4(uv * 2.0 - vec2(1.0), depth * 2.0 - 1.0 , 1.0);

	//reproject
	vec4 proj_worldpos = u_inverse_viewprojection * screen_position;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;

	//lets use 64 samples
	const int samples = SAMPLES;
	int num = samples; //num samples that passed the are outside

	mat3 rotmat = cotangent_frame( normal, worldpos, uv );

	//for every sample around the point
	for( int i = 0; i < samples; ++i ){
		//compute is world position using the random
		vec3 p = worldpos + (u_points[i] * rotmat);
		//find the uv in the depth buffer of this point
		vec4 proj = u_viewprojection * vec4(p,1.0);
		proj.xy /= proj.w; //convert to clipspace from homogeneous
		//apply a tiny bias to its z before converting to clip-space
		proj.z = (proj.z - 0.005) / proj.w;
		proj.xyz = proj.xyz * 0.5 + vec3(0.5); //to [0..1]
		//read p true depth
		float pdepth = texture( u_depth_texture, proj.xy ).x;
		//compare true depth with its depth
		if( pdepth < proj.z ) //if true depth smaller, is inside
			num--; //remove this point from the list of visible
	}

	//finally, compute the AO factor as the ratio of visible points
	float ao = float(num) / float(samples);

	FragColor = vec4(ao);
}

\blur.fs
// Sacado de https://learnopengl.com/Advanced-Lighting/SSAO
#version 330 core

out vec4 FragColor;
  
in vec2 v_uv;
  
uniform sampler2D ssaoInput;

void main() {
    vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));
    float result = 0.0;
    for (int x = -2; x < 2; ++x) 
    {
        for (int y = -2; y < 2; ++y) 
        {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            result += texture(ssaoInput, v_uv + offset).r;
        }
    }
    result = result / (4.0 * 4.0);

    FragColor = vec4(vec3(result), 1.0);	
}  


\probe.fs


#version 330 core

#include "irrProbes"

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;

uniform vec3 u_coeffs[9];

out vec4 FragColor;

void main()
{
	vec3 N = normalize(v_normal);

	SH9Color sh;
	sh.c[0] = u_coeffs[0];
	sh.c[1] = u_coeffs[1];
	sh.c[2] = u_coeffs[2];
	sh.c[3] = u_coeffs[3];
	sh.c[4] = u_coeffs[4];
	sh.c[5] = u_coeffs[5];
	sh.c[6] = u_coeffs[6];
	sh.c[7] = u_coeffs[7];
	sh.c[8] = u_coeffs[8];

	vec4 color = vec4(ComputeSHIrradiance(N, sh), 1.0);

	FragColor = color;
}