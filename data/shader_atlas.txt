//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
fx quad.vs fx.fs
multi basic.vs multi.fs
basiclight basic.vs basiclight.fs
normal basic.vs normal.fs
uvs basic.vs uvs.fs
occlusion basic.vs occlusion.fs
multipasslight basic.vs multipasslight.fs
gbuffers basic.vs gbuffers.fs

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}


\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}

\basiclight.fs

#version 330 core

const int MAX_LIGHTS = 5;
in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform vec3 u_emissive_factor;

uniform sampler2D u_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_emmisive_texture;
uniform sampler2D u_normalmap;


uniform int u_light_type[MAX_LIGHTS];
uniform vec3 u_light_pos[MAX_LIGHTS];
uniform vec3 u_light_color[MAX_LIGHTS];
uniform vec3 u_light_target[MAX_LIGHTS];
uniform float u_light_max_dists[MAX_LIGHTS];
uniform float u_light_coscutoff[MAX_LIGHTS];
uniform float u_light_spotexp[MAX_LIGHTS];
uniform int u_num_lights;


uniform float u_time;
uniform float u_alpha_cutoff;

uniform vec3 u_ambient_light;

out vec4 FragColor;

mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}

vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
    normal_pixel = normal_pixel * 255./127. - 128./127.;
    mat3 TBN = cotangent_frame(N, WP, uv);
    return normalize(TBN * normal_pixel);
}


void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	float occlusion = texture( u_metallic_roughness_texture, v_uv ).x;

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light = u_ambient_light * occlusion;

	vec3 N = normalize(v_normal);

	vec3 normal_uv = texture2D(u_normalmap,v_uv).xyz;
	N = perturbNormal(N, v_world_position, v_uv, normal_uv);

	
	for( int i = 0; i < MAX_LIGHTS; ++i ){
		if(i < u_num_lights){
			vec3 L;

			float att_factor = 1;
			float spotFactor = 1;

			vec3 D = normalize(u_light_target[i]);

			if (u_light_type[i] == 2){
				L = -D;
			}
			else{
				L = u_light_pos[i] - v_world_position;
				att_factor = u_light_max_dists[i] - length(L);
				att_factor /= u_light_max_dists[i];
				att_factor = max( att_factor, 0.0 );
				L = normalize(L);
				if (u_light_type[i] == 1){
					if (u_light_coscutoff[i] > 0.0) { 
						float spotCosine = dot(D,-L);
						if (spotCosine >= u_light_coscutoff[i]) { 
							spotFactor = pow(spotCosine, u_light_spotexp[i]);
						}
						else{
							spotFactor = 0;
						}
					}
				}
			}
			float NdotL = clamp( dot(L,N), 0.0, 1.0);
			light += NdotL * u_light_color[i] * att_factor * spotFactor;
		}
	}


	color.xyz *= light;

	color.xyz += u_emissive_factor * texture(u_emmisive_texture, v_uv).xyz;

	FragColor = color;
}

\multipasslight.fs

#version 330 core


in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform vec3 u_emissive_factor;

uniform sampler2D u_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_emmisive_texture;
uniform sampler2D u_normalmap;

uniform int u_light_type;
uniform vec3 u_light_pos;
uniform vec3 u_light_color;
uniform vec3 u_light_target;
uniform float u_light_max_dists;
uniform float u_light_coscutoff;
uniform float u_light_spotexp;
uniform int u_num_lights;


uniform sampler2D u_shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;
uniform bool u_cast_shadows;


uniform float u_time;
uniform float u_alpha_cutoff;

uniform vec3 u_ambient_light;

out vec4 FragColor;

mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}

// assume N, the interpolated vertex normal and 
// WP the world position
//vec3 normal_pixel = texture2D( normalmap, uv ).xyz; 
vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
    normal_pixel = normal_pixel * 255./127. - 128./127.;
    mat3 TBN = cotangent_frame(N, WP, uv);
    return normalize(TBN * normal_pixel);
}

float getShadowFactor(bool directional)
{
//project our 3D position to the shadowmap
	vec4 proj_pos = u_shadow_viewproj * vec4(v_world_position,1.0);

	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;

	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);

	//get point depth [-1 .. +1] in non-linear space
	float real_depth = (proj_pos.z - u_shadow_bias) / proj_pos.w;

	//normalize from [-1..+1] to [0..+1] still non-linear
	real_depth = real_depth * 0.5 + 0.5;

	//read depth from depth buffer in [0..+1] non-linear
	float shadow_depth = texture( u_shadowmap, shadow_uv).x;

	//compute final shadow factor by comparing
	float shadow_factor = 1.0;

	//we can compare them, even if they are not linear
	if( shadow_depth < real_depth )
		shadow_factor = 0.0;

	if (directional){

		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 ||
		shadow_uv.y < 0.0 || shadow_uv.y > 1.0 )
			shadow_factor = 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			shadow_factor = 1.0;

	}
		
	
	return shadow_factor;
}


void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	float occlusion = texture( u_metallic_roughness_texture, v_uv ).x;

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light = u_ambient_light * occlusion;
	vec3 N = normalize(v_normal);

	vec3 normal_uv = texture2D(u_normalmap,v_uv).xyz;
	N = perturbNormal(N, v_world_position, v_uv, normal_uv);



	vec3 L;

	float att_factor = 1.0;
	float spotFactor = 1.0;
	float shadow_factor = 1.0;

	vec3 D = normalize(u_light_target);

	if (u_light_type == 2){
		L = -D;
		if (u_cast_shadows) shadow_factor = getShadowFactor(true);
	}
	else{
		L = u_light_pos - v_world_position;
		att_factor = u_light_max_dists - length(L);
		att_factor /= u_light_max_dists;
		att_factor = max( att_factor, 0.0 );
		L = normalize(L);
		if (u_light_type == 1){
			if (u_cast_shadows) shadow_factor = getShadowFactor(false);
			if (u_light_coscutoff > 0.0) { 
				float spotCosine = dot(D,-L);
				if (spotCosine >= u_light_coscutoff) { 
					spotFactor = pow(spotCosine, u_light_spotexp);
				}
				else{
					spotFactor = 0;
				}
			}
		}
	}



	float NdotL = clamp( dot(L,N), 0.0, 1.0);
	light += NdotL * u_light_color * att_factor * spotFactor * shadow_factor;

	color.xyz *= light;

	color.xyz += u_emissive_factor * texture(u_emmisive_texture, v_uv).xyz;

	FragColor = color;
}

\gbuffers.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform vec3 u_emissive_factor;

uniform sampler2D u_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_emmisive_texture;
uniform sampler2D u_normalmap;


uniform float u_time;
uniform float u_alpha_cutoff;

uniform vec3 u_ambient_light;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;
layout(location = 2) out vec4 ExtraColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	float occlusion = texture( u_metallic_roughness_texture, v_uv ).x;

	vec3 N = normalize( v_normal );
	FragColor = color;
	NormalColor = vec4(N * 0.5 + vec3(0.5),1.0);
	ExtraColor = vec4(v_world_position, 1.0);
}


\normal.fs

#version 330 core

in vec3 v_normal;
out vec4 FragColor;

void main()
{
	FragColor = vec4( abs(normalize(v_normal)), 1.0);
}

\uvs.fs

#version 330 core

in vec2 v_uv;

out vec4 FragColor;

void main()
{

	FragColor = vec4(v_uv, 1.0, 1.0);
}

\occlusion.fs

#version 330 core

in vec2 v_uv;
uniform sampler2D u_metallic_roughness_texture;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	float occ = texture( u_metallic_roughness_texture, v_uv ).x;
	FragColor = vec4(occ, occ, occ, 1.0);
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}

\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	FragColor = vec4(color);
}


\fx.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture; //depth map
uniform float u_time;
out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = texture( u_texture, uv );
	color = vec4(1.0) - color;
	FragColor = color;
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}